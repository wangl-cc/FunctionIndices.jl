var documenterSearchIndex = {"docs":
[{"location":"performance/#Performance-of-not","page":"Performance of not","title":"Performance of not","text":"","category":"section"},{"location":"performance/#Optimizations-for-not-with-special-index-types","page":"Performance of not","title":"Optimizations for not with special index types","text":"","category":"section"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"For faster indexing, this package provides optimizations for not with some special index types, which means not(x) is not equivalent to FI(!in(x)) for x belonging to those index types, and will be converted to different index types by to_indices function.","category":"page"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"There are two list of those index types, both of which are enabled for not, but for customized NotIndex types, optimizations in second list is enabled when indextype returns Vector{Int}.","category":"page"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"There optimizations are enabled for any AbstractNotIndex types by default:","category":"page"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"x::Colon will be converted to an empty Int array: Int[];\nx::AbstractArray{Bool} will be converted to a LogicalIndex with mask mappedarray(!, x);\nx::AbstractArray will be converted like FI(!in(x′)), while x′ is a Set like array converted from x with faster in;\nFor I′, J′ = to_indices(A, (not(I), not(J))), not(I′) and not(I′) will revert to I, J.","category":"page"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"There optimizations are enabled only if indextype is defined as Vector{Int}:","category":"page"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"x::Integer or x::OrdinalRange{<:Integer} will be converted to an Int array  where x is removed from given axis.\nx::Base.Slice will be converted to an empty Int array, when the slice represents the given axis, Otherwise, it will be treated as a normal AbstractUnitRange.","category":"page"},{"location":"performance/#Performance-tips-for-not","page":"Performance of not","title":"Performance tips for not","text":"","category":"section"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"For small array, the optimized not(x) might be slower in some case, because of the overhead for creating a Set, see below.","category":"page"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"There are some tips for better performance:","category":"page"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"Use FI(!in(x)) instead of not(x).\nCreate your own \"Not\" type, see below example for details.\nFor a small array of indices, not(1, 2, 3) will faster than not([1, 2, 3]).","category":"page"},{"location":"performance/#performance","page":"Performance of not","title":"Performance comparing","text":"","category":"section"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"This is a performance comparing of \"Inverted Indexing\" for different methods. There are five methods:","category":"page"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"bynot: by not of this package;\nbyfi: by function index FI(!in(I));\nbymap: by logical indices which test map(!in(I), axis);\nbyfilter: by removing I from axes by filter;\nbyNot: by InvertedIndices.Not.","category":"page"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"The minimum time and allocation of each method for different type of index were compared:","category":"page"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"using BenchmarkTools\nusing InvertedIndices\nusing FunctionIndices\nusing Latexify\n\n# Linear\nbynot(A, I) = A[not(I)]\nbyfi(A, I) = A[FI(!in(I))]\nbymap(A, I) = A[map(!in(I), begin:end)]\nbyfilter(A, I) = A[filter(!in(I), begin:end)]\nbyNot(A, I) = A[Not(I)]\n\n# Cartesian\nbynot(A, Is...) = A[ntuple(i -> not(Is[i]), Val(length(Is)))...]\nbyfi(A, Is...) = A[ntuple(i -> FI(!in(Is[i])), Val(length(Is)))...]\nbymap(A, Is...) = A[ntuple(i -> map(!in(Is[i]), axes(A, i)), Val(length(Is)))...]\nbyfilter(A, Is...) = A[ntuple(i -> filter(!in(Is[i]), axes(A, i)), Val(length(Is)))...]\nbyNot(A, Is...) = A[ntuple(i -> Not(Is[i]), Val(length(Is)))...]\n\nconst As = (rand(10), rand(10, 10), rand(10, 10, 10))\nconst fs = (bynot, byfi, bymap, byfilter, byNot)\n\n# convert tuple of tuple to matrix\ntt2mt(trs) = hcat(map(tr -> vcat(tr...), trs)...)\n\nmaketable(bench, As::Tuple=As, fs::Tuple=fs) = mdtable(\n    # use map of map instead of for loop for typle stable\n    map(\n        f -> map(\n            A -> begin\n                trial = bench(f, A)\n                trialmin = minimum(trial)\n                trialallocs = allocs(trialmin)\n                string(\n                    BenchmarkTools.prettytime(time(trialmin)),\n                    \" (\", trialallocs , \" alloc\",\n                    trialallocs == 1 ? \"\" : \"s\", \": \",\n                    BenchmarkTools.prettymemory(memory(trialmin)), \")\"\n                )\n            end,\n            As\n        ),\n        fs\n    ) |> tt2mt;\n    head=fs, side=[:Size; size.(As)...], latex=false,\n);","category":"page"},{"location":"performance/#Indexing-with-Int","page":"Performance of not","title":"Indexing with Int","text":"","category":"section"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"A random inbounds Int index.","category":"page"},{"location":"performance/#Linear-Indexing","page":"Performance of not","title":"Linear Indexing","text":"","category":"section"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"maketable() do f, A\n    ind = rand(firstindex(A):lastindex(A))\n    @benchmark $f($A, $ind)\nend","category":"page"},{"location":"performance/#Multidimensional-Indexing","page":"Performance of not","title":"Multidimensional Indexing","text":"","category":"section"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"maketable() do f, A\n    inds = ntuple(i -> rand(axes(A, i)), Val(ndims(A)))\n    @benchmark $f($A, $inds...)\nend","category":"page"},{"location":"performance/#Indexing-with-UnitRange","page":"Performance of not","title":"Indexing with UnitRange","text":"","category":"section"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"A random inbound UnitRange with half-length of axe.","category":"page"},{"location":"performance/#Linear-Indexing-2","page":"Performance of not","title":"Linear Indexing","text":"","category":"section"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"maketable() do f, A\n    axe = firstindex(A):lastindex(A)\n    half = length(axe) ÷ 2\n    b = rand(axe[begin:(end - half)])\n    e = b + half\n    @benchmark $f($A, $(b:e))\nend","category":"page"},{"location":"performance/#Multidimensional-Indexing-2","page":"Performance of not","title":"Multidimensional Indexing","text":"","category":"section"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"maketable() do f, A\n    inds = ntuple(\n        i -> begin\n            axe = axes(A, i)\n            half = length(axe) ÷ 2\n            b = rand(axe[begin:(end - half)])\n            e = b + half\n            b:e\n        end,\n        Val(ndims(A))\n    )\n    @benchmark $f($A, $inds...)\nend","category":"page"},{"location":"performance/#Indexing-with-StepRange","page":"Performance of not","title":"Indexing with StepRange","text":"","category":"section"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"A StepRange with step 2.","category":"page"},{"location":"performance/#Linear-Indexing-3","page":"Performance of not","title":"Linear Indexing","text":"","category":"section"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"maketable() do f, A\n    ind = firstindex(A):2:lastindex(A)\n    @benchmark $f($A, $ind)\nend","category":"page"},{"location":"performance/#Multidimensional-Indexing-3","page":"Performance of not","title":"Multidimensional Indexing","text":"","category":"section"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"maketable() do f, A\n    inds = ntuple(\n        i -> begin\n            axe = axes(A, i)\n            axe[begin:2:end]\n        end,\n        Val(ndims(A))\n    )\n    @benchmark $f($A, $inds...)\nend","category":"page"},{"location":"performance/#Indexing-with-Vector{Int}","page":"Performance of not","title":"Indexing with Vector{Int}","text":"","category":"section"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"A Vector{Int} which is a collected StepRange.","category":"page"},{"location":"performance/#Linear-Indexing-4","page":"Performance of not","title":"Linear Indexing","text":"","category":"section"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"maketable() do f, A\n    ind = collect(firstindex(A):2:lastindex(A))\n    @benchmark $f($A, $ind)\nend","category":"page"},{"location":"performance/#Multidimensional-Indexing-4","page":"Performance of not","title":"Multidimensional Indexing","text":"","category":"section"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"maketable() do f, A\n    inds = ntuple(\n        i -> begin\n            axe = axes(A, i)\n            collect(axe[begin:2:end])\n        end,\n        Val(ndims(A))\n    )\n    @benchmark $f($A, $inds...)\nend","category":"page"},{"location":"referances/#References","page":"References","title":"References","text":"","category":"section"},{"location":"referances/","page":"References","title":"References","text":"Modules = [FunctionIndices]","category":"page"},{"location":"referances/#FunctionIndices.AbstractFunctionIndex","page":"References","title":"FunctionIndices.AbstractFunctionIndex","text":"AbstractFunctionIndex\n\nSupertype of all function index types.\n\n\n\n\n\n","category":"type"},{"location":"referances/#FunctionIndices.AbstractNotIndex","page":"References","title":"FunctionIndices.AbstractNotIndex","text":"AbstractNotIndex{T}\n\nSupertype of all not types which create by not.\n\n\n\n\n\n","category":"type"},{"location":"referances/#FunctionIndices.FunctionIndex","page":"References","title":"FunctionIndices.FunctionIndex","text":"FunctionIndex{F} <: AbstractFunctionIndex\nFI\n\nA implementation of function index, which make indexing with function possible. 1-d indexing A[FI(f)] is equivalent to A[map(f, begin:end)], multi-dimensional indexing A[FI(f1), ..., FI(fn)] is equivalent to A[map(FI(f1), axes(A, 1)), ..., map(FI(fn), axes(A, n))].\n\n\n\n\n\n","category":"type"},{"location":"referances/#FunctionIndices.NotIndex","page":"References","title":"FunctionIndices.NotIndex","text":"NotIndex{T} <: AbstractNotIndex{T}\n\nThe default implementation of not. There are some optimization for NotIndex(x) comparing to FI(!in(x)). For large arrays, this implementation may be faster. but for small arrays this implementation may be slower. See performance comparing for more details.\n\n\n\n\n\n","category":"type"},{"location":"referances/#FunctionIndices.indextype-Tuple{AbstractArray, FunctionIndices.AbstractFunctionIndex}","page":"References","title":"FunctionIndices.indextype","text":"indextype([A::AbstractArray,] I::AbstractFunctionIndex)\nindextype([::Type{TA},] ::Type{TI})\n\nDetermine the index type which the function index type TI will be converted to by Base.to_indices for array type TA. By default, it's AbstractArray.\n\nnote: Note\nIf you define a methods indextype(::Type{TA}, ::Type{TI}) = T, while to_index(::Type{T}, inds, I::TI) is not defined, the to_indices will not convert a index of type TI to a T, but a Base.LogicalIndex, the default return type of to_index.\n\n\n\n\n\n","category":"method"},{"location":"referances/#FunctionIndices.not-Tuple{Any}","page":"References","title":"FunctionIndices.not","text":"not(x)\n\nCreate a NotIndex with given x, which is similar to Not of InvertedIndices. In most cases, not is much faster than Not. See performance comparing for more details.\n\nMain differences between not and Not\n\nFor CartesianIndex, A[not(CartesianIndex(i, j,..., n))] is equivalent to A[not(i), not(j), ..., not(n)] and will return a array with same dimension, but A[Not(CartesianIndex(i, j,..., n))] will convert the CartesianIndex to a linear index and return a vector:\n\njulia> A = reshape(1:12, 3, 4)\n3×4 reshape(::UnitRange{Int64}, 3, 4) with eltype Int64:\n 0  3  6   9\n 1  4  7  10\n 2  5  8  11\n\njulia> A[not(CartesianIndex(1, 2))] # equivalent to A[not(1), not(2)]\n2×3 Matrix{Int64}:\n 1  7  10\n 2  8  11\n\njulia> A[Not(CartesianIndex(1, 2))] # equivalent to A[Not(3)]\n11-element Vector{Int64}:\n  0\n  1\n  2\n  4\n  5\n  ⋮\n  8\n  9\n 10\n 11\n\nBesides, for index like A[4, 5] which is out of bounds, A[not(4), not(5)] is equivalent to A[:, :], because inbounds indices are always not equal to the given value, while A[Not[4], Not(5)] causes an error.\n\n\n\n\n\n","category":"method"},{"location":"referances/#FunctionIndices.notin-Tuple{Any, Any}","page":"References","title":"FunctionIndices.notin","text":"notin(item, collection)\nnotin(collection)\n\nThe same as !in, used in the default to_function for AbstractNotIndex.\n\n\n\n\n\n","category":"method"},{"location":"referances/#FunctionIndices.to_function","page":"References","title":"FunctionIndices.to_function","text":"to_function(I::AbstractFunctionIndex)\n\nConverts a AbstractFunctionIndex to a Function. By default, to_function(I::AbstractNotIndex) returns notin(parent(I)).\n\n\n\n\n\n","category":"function"},{"location":"referances/#FunctionIndices.to_index-Union{Tuple{T}, Tuple{Type{T}, Any, Any, Any}} where T<:AbstractArray","page":"References","title":"FunctionIndices.to_index","text":"FunctionIndices.to_index(::Type{T<:AbstractArray}, A, ind, i)\n\nConvert a AbstractFunctionIndex i to a array index of type T for A with ind. By default, to_index(::AbstractArray, ind, i) will return a Base.LogicalIndex{Bool, ReadonlyMappedArray{Bool...}}.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Internal","page":"Internal","title":"Internal","text":"","category":"section"},{"location":"internal/#AbstractFunctionIndex-interface","page":"Internal","title":"AbstractFunctionIndex interface","text":"","category":"section"},{"location":"internal/","page":"Internal","title":"Internal","text":"This package defines a type AbstractFunctionIndex (AFI for short) which can be converted to an array index by Base.to_indices. To define a new type of AbstractFunctionIndex, you need to implement the following methods:","category":"page"},{"location":"internal/","page":"Internal","title":"Internal","text":"Method Defaults Description\nto_function(I) required convert the given AFI to a function;\nindextype AbstractArray determines the return index of to_index type converted from AFI;\nto_index map function of AFI to axis convert AFI to an index;","category":"page"},{"location":"internal/#AbstractNotIndex-interface","page":"Internal","title":"AbstractNotIndex interface","text":"","category":"section"},{"location":"internal/","page":"Internal","title":"Internal","text":"AbstractNotIndex is a subtype of AbstractFunctionIndex, which represents an inverted index. To define a new type of AbstractNotIndex, the only needed method is Base.parent, which returns the parent index which is inverted by this index. to_function for AbstractNotIndex is pre-defined as notin(parent(I)).","category":"page"},{"location":"internal/#example","page":"Internal","title":"Define a new NotIndex","text":"","category":"section"},{"location":"internal/","page":"Internal","title":"Internal","text":"If you don't like the default behaviour of not, creating a new Notindex type is easy:","category":"page"},{"location":"internal/","page":"Internal","title":"Internal","text":"using FunctionIndices\nstruct YatAnotherNotIndex{T} <: FunctionIndices.AbstractNotIndex{T}\n    parent::T\nend\nconst YANI = YatAnotherNotIndex\nBase.parent(I::YatAnotherNotIndex) = I.parent\nreshape(1:10, 2, 5)[YANI(1), YANI(2)]","category":"page"},{"location":"internal/","page":"Internal","title":"Internal","text":"If a big array of linear indices I should be excluded, create a new index array by setdiff might faster than map(!in(I)). You can do this by defining indextype and to_index for YANI:","category":"page"},{"location":"internal/","page":"Internal","title":"Internal","text":"FunctionIndices.indextype(::Type{<:AbstractArray}, ::Type{<:YANI{<:Array{<:Integer}}}) = Vector{Int}\nFunctionIndices.to_index(::Type{Vector{Int}}, A, ind, I::YANI{<:Array{<:Integer}}) = setdiff(ind, parent(I))::Vector{Int}\nto_indices(0:10, (YANI([1, 2, 3]),))","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A small package allows to access array elements by a function via a simple wrapper FI. As a special case, for indexing with !=(n), !in(itr), there is another wrapper not providing a convenient and optimized way. The not is similar to Not of InvertedIndices, but faster in some cases. Besides, this package also provides ways to change the behavior for special array types and function index types.","category":"page"},{"location":"#Quick-start","page":"Introduction","title":"Quick start","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"1-d indexing A[FI(f)] is equivalent to A[map(f, begin:end)], multi-dimensional indexing A[FI(f1), ..., FI(fn)] is equivalent to A[map(FI(f1), axes(A, 1)), ..., map(FI(fn), axes(A, n))].","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using FunctionIndices\nA = reshape(0:11, 3, 4)\nA[FI(iseven)]\nA[map(iseven, begin:end)]\nA[FI(isodd), FI(iseven)]\nA[map(isodd, begin:end), map(iseven, begin:end)]","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"not is an alternative to Not and in most cases they are equivalent:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using InvertedIndices\nA[not(1)] == A[Not(1)]\nA[not(1, 2)] == A[Not(1, 2)]\nA[not(1:2)] == A[Not(1:2)]\nlet I = rand(Bool, size(A)); A[not(I)] == A[Not(I)] end","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"But for CartesianIndex and CartesianIndices, A[not(CartesianIndex(i, j,...))] is equivalent to A[not(i), not(j), ...] and A[not(CartesianIndices((I, J,...))] is equivalent to A[not(I), not(J), ...]. which return arrays with same dimension, while A[Not(CartesianIndex(i, j,...))] will convert the CartesianIndex to a linear index and return a vector, and A[Not(CartesianIndices((I, J,...)))] seams an undefined behavior.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A[not(CartesianIndex(1, 2))] # equivalent to A[not(1), not(2)]\nA[Not(CartesianIndex(1, 2))] # equivalent to A[Not(3)]\nA[not(CartesianIndex(1, 2):CartesianIndex(2, 3))] # equivalent to A[not(1:2), not(2:3)]\nA[Not(CartesianIndex(1, 2):CartesianIndex(2, 3))] # seems an undefined behavior","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"because inbounds indices are not equal to the given value, while A[Not[4], Not(5)] throws an error.","category":"page"},{"location":"#Mechanism","page":"Introduction","title":"Mechanism","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package define a type AbstractFunctionIndex (AFI for short) which can be convert ed to a array index by Base.to_indices.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"There are three methods determining how to convert AFI to array index:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"FunctionIndices.to_index: this function is the direct method converting AFI. The default method of to_index converting AFI to a function and map it for ind. Besides, the to_index also accepts a Type argument, which is determining call which method of to_index to convert AFI.\nFunctionIndices.to_function: this function is called in default method to_index and convert the given AFI to a function.\nFunctionIndices.indextype: this function is called in to_indices and returns a type as the Type argument of to_index. The indextype accepts two arguments, the type of array and type of a AFI.","category":"page"},{"location":"#Optimizations-for-not-with-special-index-types","page":"Introduction","title":"Optimizations for not with special index types","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"For faster indexing, this package provides optimizations for not with some special index types, which means not(x) is not equivalent to FI(!in(x)) for x belonging to those index types, and will be converted to different index types by to_indices function.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"There are two list of those index types, both of which are enabled for not, but for customized \"NotIndex\" types, you need to enable them by indextype.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"There optimizations are enabled for any \"NotIndex\" types by default:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"x::Colon will be converted to an empty Int array: Int[];\nx::AbstractArray{Bool} will be converted to an LogicalIndex with mask mappedarray(!, x);\nx::AbstractArray will be converted like FI(!in(x′)), while x′ is a Set like array converted from x with faster in;\nFor I′, J′ = to_indices(A, (not(I), not(J))), not(I′) and not(I′) will revert to I, J.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"There optimizations are enabled only if indextype is defined as Vector{Int}:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"x::Integer will be converted to an Int array where x is removed from given axe.\nx::OrdinalRange{<:Integer} will be converted to an Int array which is a set difference[1] of given ind and x\nx::Base.Slice will be converted to an empty Int array, when the slice represents the given axe. Otherwise, it will be treated as a normal AbstractUnitRange.","category":"page"},{"location":"#Performant-tips-for-not","page":"Introduction","title":"Performant tips for not","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"For small array, the optimized not(x) might be slower in some case, because of the overhead for creating a Set. see performance comparing for details.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"There are some tips for better performance:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Use FI(!in(x)) instead of not(x).\nCreate your own \"Not\" type, see below example for details.\nFor a small array of indices like not([1, 2, 3]), not(1, 2, 3) will faster.","category":"page"},{"location":"#intro-example","page":"Introduction","title":"Example to define \"Not\"","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"If you don't like the default behavior of not, creating a new \"Not\" index type is easy:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using FunctionIndices\nstruct YatAnotherNotIndex{T} <: FunctionIndices.AbstractNotIndex{T}\n    parent::T\nend\nconst YANI = YatAnotherNotIndex\nBase.parent(I::YatAnotherNotIndex) = I.parent\nreshape(1:10, 2, 5)[YANI(1), YANI(2)]","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"info: Info\nto_function for AbstractNotIndex is pre-defined as notin(parent(I)).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"If a big array of linear indices I should be exclude, create a new index array by setdiff might faster than map(!in(I)). You can do this by Defining indextype and to_index for YANI:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"FunctionIndices.indextype(::Type{<:AbstractArray}, ::Type{<:YANI{<:Array{<:Integer}}}) = Vector{Int}\nFunctionIndices.to_index(::Type{Vector{Int}}, A, ind, I::YANI{<:Array{<:Integer}}) = setdiff(ind, parent(I))::Vector{Int}\ntypeof(to_indices(0:10, (YANI([1, 2, 3]),))[1]), typeof(to_indices(0:10, (not([1, 2, 3]),))[1])","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"[1]: The set difference is not calculated by setdiff from julia base library, but optimized for each OrdinalRange types. see source code of for details.","category":"page"}]
}
