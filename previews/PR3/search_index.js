var documenterSearchIndex = {"docs":
[{"location":"performance/#Performance-of-not","page":"Performance of not","title":"Performance of not","text":"","category":"section"},{"location":"performance/#Optimizations-for-not-with-special-index-types","page":"Performance of not","title":"Optimizations for not with special index types","text":"","category":"section"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"For faster indexing, this package provides optimizations for not with some special index types, which means not(x) is not equivalent to FI(!in(x)) for x belonging to those index types, and will be converted to different index types by to_indices function.","category":"page"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"There are two list of those index types, both of which are enabled for not, but for customized NotIndex types, optimizations in second list is enabled when indextype returns Vector{Int}.","category":"page"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"There optimizations are enabled for any AbstractNotIndex types by default:","category":"page"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"x::Colon will be converted to an empty Int array: Int[];\nx::AbstractArray{Bool} will be converted to a LogicalIndex with mask mappedarray(!, x);\nx::AbstractArray will be converted like FI(!in(x′)), while x′ is a Set like array converted from x with faster in;\nFor I′, J′ = to_indices(A, (not(I), not(J))), not(I′) and not(I′) will revert to I, J.","category":"page"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"There optimizations are enabled only if indextype is defined as Vector{Int}:","category":"page"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"x::Integer or x::OrdinalRange{<:Integer} will be converted to an Int array  where x is removed from given axis.\nx::Base.Slice will be converted to an empty Int array, when the slice represents the given axis, Otherwise, it will be treated as a normal AbstractUnitRange.","category":"page"},{"location":"performance/#Performance-tips-for-not","page":"Performance of not","title":"Performance tips for not","text":"","category":"section"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"For small array, the optimized not(x) might be slower in some case, because of the overhead for creating a Set, see below.","category":"page"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"There are some tips for better performance:","category":"page"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"Use FI(!in(x)) instead of not(x).\nCreate your own \"Not\" type, see below example for details.\nFor a small array of indices, not(1, 2, 3) will faster than not([1, 2, 3]).","category":"page"},{"location":"performance/#performance","page":"Performance of not","title":"Performance comparing","text":"","category":"section"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"This is a performance comparing of \"Inverted Indexing\" for different methods. There are five methods:","category":"page"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"bynot: by not of this package;\nbyfi: by function index FI(!in(I));\nbymap: by logical indices which test map(!in(I), axis);\nbyfilter: by removing I from axes by filter;\nbyNot: by InvertedIndices.Not.","category":"page"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"The minimum time and allocation of each method for different type of index were compared:","category":"page"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"using BenchmarkTools\nusing InvertedIndices\nusing FunctionIndices\nusing Latexify\n\n# Linear\nbynot(A, I) = A[not(I)]\nbyfi(A, I) = A[FI(!in(I))]\nbymap(A, I) = A[map(!in(I), begin:end)]\nbyfilter(A, I) = A[filter(!in(I), begin:end)]\nbyNot(A, I) = A[Not(I)]\n\n# Cartesian\nbynot(A, Is...) = A[ntuple(i -> not(Is[i]), Val(length(Is)))...]\nbyfi(A, Is...) = A[ntuple(i -> FI(!in(Is[i])), Val(length(Is)))...]\nbymap(A, Is...) = A[ntuple(i -> map(!in(Is[i]), axes(A, i)), Val(length(Is)))...]\nbyfilter(A, Is...) = A[ntuple(i -> filter(!in(Is[i]), axes(A, i)), Val(length(Is)))...]\nbyNot(A, Is...) = A[ntuple(i -> Not(Is[i]), Val(length(Is)))...]\n\nconst As = (rand(10), rand(10, 10), rand(10, 10, 10))\nconst fs = (bynot, byfi, bymap, byfilter, byNot)\n\n# convert tuple of tuple to matrix\ntt2mt(trs) = hcat(map(tr -> vcat(tr...), trs)...)\n\nmaketable(bench, As::Tuple=As, fs::Tuple=fs) = mdtable(\n    # use map of map instead of for loop for typle stable\n    map(\n        f -> map(\n            A -> begin\n                trial = bench(f, A)\n                trialmin = minimum(trial)\n                trialallocs = allocs(trialmin)\n                string(\n                    BenchmarkTools.prettytime(time(trialmin)),\n                    \" (\", trialallocs , \" alloc\",\n                    trialallocs == 1 ? \"\" : \"s\", \": \",\n                    BenchmarkTools.prettymemory(memory(trialmin)), \")\"\n                )\n            end,\n            As\n        ),\n        fs\n    ) |> tt2mt;\n    head=fs, side=[:Size; size.(As)...], latex=false,\n);","category":"page"},{"location":"performance/#Indexing-with-Int","page":"Performance of not","title":"Indexing with Int","text":"","category":"section"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"A random inbounds Int index.","category":"page"},{"location":"performance/#Linear-Indexing","page":"Performance of not","title":"Linear Indexing","text":"","category":"section"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"maketable() do f, A\n    ind = rand(firstindex(A):lastindex(A))\n    @benchmark $f($A, $ind)\nend","category":"page"},{"location":"performance/#Multidimensional-Indexing","page":"Performance of not","title":"Multidimensional Indexing","text":"","category":"section"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"maketable() do f, A\n    inds = ntuple(i -> rand(axes(A, i)), Val(ndims(A)))\n    @benchmark $f($A, $inds...)\nend","category":"page"},{"location":"performance/#Indexing-with-UnitRange","page":"Performance of not","title":"Indexing with UnitRange","text":"","category":"section"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"A random inbound UnitRange with half-length of axe.","category":"page"},{"location":"performance/#Linear-Indexing-2","page":"Performance of not","title":"Linear Indexing","text":"","category":"section"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"maketable() do f, A\n    axe = firstindex(A):lastindex(A)\n    half = length(axe) ÷ 2\n    b = rand(axe[begin:(end - half)])\n    e = b + half\n    @benchmark $f($A, $(b:e))\nend","category":"page"},{"location":"performance/#Multidimensional-Indexing-2","page":"Performance of not","title":"Multidimensional Indexing","text":"","category":"section"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"maketable() do f, A\n    inds = ntuple(\n        i -> begin\n            axe = axes(A, i)\n            half = length(axe) ÷ 2\n            b = rand(axe[begin:(end - half)])\n            e = b + half\n            b:e\n        end,\n        Val(ndims(A))\n    )\n    @benchmark $f($A, $inds...)\nend","category":"page"},{"location":"performance/#Indexing-with-StepRange","page":"Performance of not","title":"Indexing with StepRange","text":"","category":"section"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"A StepRange with step 2.","category":"page"},{"location":"performance/#Linear-Indexing-3","page":"Performance of not","title":"Linear Indexing","text":"","category":"section"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"maketable() do f, A\n    ind = firstindex(A):2:lastindex(A)\n    @benchmark $f($A, $ind)\nend","category":"page"},{"location":"performance/#Multidimensional-Indexing-3","page":"Performance of not","title":"Multidimensional Indexing","text":"","category":"section"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"maketable() do f, A\n    inds = ntuple(\n        i -> begin\n            axe = axes(A, i)\n            axe[begin:2:end]\n        end,\n        Val(ndims(A))\n    )\n    @benchmark $f($A, $inds...)\nend","category":"page"},{"location":"performance/#Indexing-with-Vector{Int}","page":"Performance of not","title":"Indexing with Vector{Int}","text":"","category":"section"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"A Vector{Int} which is a collected StepRange.","category":"page"},{"location":"performance/#Linear-Indexing-4","page":"Performance of not","title":"Linear Indexing","text":"","category":"section"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"maketable() do f, A\n    ind = collect(firstindex(A):2:lastindex(A))\n    @benchmark $f($A, $ind)\nend","category":"page"},{"location":"performance/#Multidimensional-Indexing-4","page":"Performance of not","title":"Multidimensional Indexing","text":"","category":"section"},{"location":"performance/","page":"Performance of not","title":"Performance of not","text":"maketable() do f, A\n    inds = ntuple(\n        i -> begin\n            axe = axes(A, i)\n            collect(axe[begin:2:end])\n        end,\n        Val(ndims(A))\n    )\n    @benchmark $f($A, $inds...)\nend","category":"page"},{"location":"referances/#References","page":"References","title":"References","text":"","category":"section"},{"location":"referances/","page":"References","title":"References","text":"Modules = [FunctionIndices]","category":"page"},{"location":"referances/#FunctionIndices.AbstractFunctionIndex","page":"References","title":"FunctionIndices.AbstractFunctionIndex","text":"AbstractFunctionIndex\n\nSupertype of all function index types.\n\n\n\n\n\n","category":"type"},{"location":"referances/#FunctionIndices.AbstractNotIndex","page":"References","title":"FunctionIndices.AbstractNotIndex","text":"AbstractNotIndex{T}\n\nSupertype of all not types which create by not.\n\n\n\n\n\n","category":"type"},{"location":"referances/#FunctionIndices.FunctionIndex","page":"References","title":"FunctionIndices.FunctionIndex","text":"FunctionIndex{F} <: AbstractFunctionIndex\nFI\n\nA implementation of function index, which make indexing with function possible. 1-d indexing A[FI(f)] is equivalent to A[map(f, begin:end)], multi-dimensional indexing A[FI(f1), ..., FI(fn)] is equivalent to A[map(FI(f1), axes(A, 1)), ..., map(FI(fn), axes(A, n))].\n\n\n\n\n\n","category":"type"},{"location":"referances/#FunctionIndices.NotIndex","page":"References","title":"FunctionIndices.NotIndex","text":"NotIndex{T} <: AbstractNotIndex{T}\n\nThe default implementation of not. There are some optimization for NotIndex(x) comparing to FI(!in(x)). For large arrays, this implementation may be faster. but for small arrays this implementation may be slower. See performance comparing for more details.\n\n\n\n\n\n","category":"type"},{"location":"referances/#FunctionIndices.indextype-Tuple{AbstractArray, FunctionIndices.AbstractFunctionIndex}","page":"References","title":"FunctionIndices.indextype","text":"indextype([A::AbstractArray,] I::AbstractFunctionIndex)\nindextype([::Type{TA},] ::Type{TI})\n\nDetermine the index type which the function index type TI will be converted to by Base.to_indices for array type TA. By default, it's AbstractArray.\n\nnote: Note\nIf you define a methods indextype(::Type{TA}, ::Type{TI}) = T, while to_index(::Type{T}, inds, I::TI) is not defined, the to_indices will not convert a index of type TI to a T, but a Base.LogicalIndex, the default return type of to_index.\n\n\n\n\n\n","category":"method"},{"location":"referances/#FunctionIndices.not-Tuple{Any}","page":"References","title":"FunctionIndices.not","text":"not(x)\n\nCreate a NotIndex with given x, which is similar to Not of InvertedIndices. In most cases, not is much faster than Not. See performance comparing for more details.\n\nMain differences between not and Not\n\nFor CartesianIndex, A[not(CartesianIndex(i, j,..., n))] is equivalent to A[not(i), not(j), ..., not(n)] and will return a array with same dimension, but A[Not(CartesianIndex(i, j,..., n))] will convert the CartesianIndex to a linear index and return a vector:\n\njulia> A = reshape(1:12, 3, 4)\n3×4 reshape(::UnitRange{Int64}, 3, 4) with eltype Int64:\n 0  3  6   9\n 1  4  7  10\n 2  5  8  11\n\njulia> A[not(CartesianIndex(1, 2))] # equivalent to A[not(1), not(2)]\n2×3 Matrix{Int64}:\n 1  7  10\n 2  8  11\n\njulia> A[Not(CartesianIndex(1, 2))] # equivalent to A[Not(3)]\n11-element Vector{Int64}:\n  0\n  1\n  2\n  4\n  5\n  ⋮\n  8\n  9\n 10\n 11\n\nBesides, for index like A[4, 5] which is out of bounds, A[not(4), not(5)] is equivalent to A[:, :], because inbounds indices are always not equal to the given value, while A[Not[4], Not(5)] causes an error.\n\n\n\n\n\n","category":"method"},{"location":"referances/#FunctionIndices.notin-Tuple{Any, Any}","page":"References","title":"FunctionIndices.notin","text":"notin(item, collection)\nnotin(collection)\n\nThe same as !in, used in the default to_function for AbstractNotIndex.\n\n\n\n\n\n","category":"method"},{"location":"referances/#FunctionIndices.to_function","page":"References","title":"FunctionIndices.to_function","text":"to_function(I::AbstractFunctionIndex)\n\nConverts a AbstractFunctionIndex to a Function. By default, to_function(I::AbstractNotIndex) returns notin(parent(I)).\n\n\n\n\n\n","category":"function"},{"location":"referances/#FunctionIndices.to_index-Union{Tuple{T}, Tuple{Type{T}, Any, Any, Any}} where T<:AbstractArray","page":"References","title":"FunctionIndices.to_index","text":"FunctionIndices.to_index(::Type{T<:AbstractArray}, A, ind, i)\n\nConvert a AbstractFunctionIndex i to a array index of type T for A with ind. By default, to_index(::AbstractArray, ind, i) will return a Base.LogicalIndex{Bool, ReadonlyMappedArray{Bool...}}.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Internal","page":"Internal","title":"Internal","text":"","category":"section"},{"location":"internal/#AbstractFunctionIndex-interface","page":"Internal","title":"AbstractFunctionIndex interface","text":"","category":"section"},{"location":"internal/","page":"Internal","title":"Internal","text":"This package defines a type AbstractFunctionIndex (AFI for short) which can be converted to an array index by Base.to_indices. To define a new type of AbstractFunctionIndex, you need to implement the following methods:","category":"page"},{"location":"internal/","page":"Internal","title":"Internal","text":"Method Defaults Description\nto_function(I) required convert the given AFI to a function;\nindextype AbstractArray determines the return index of to_index type converted from AFI;\nto_index map function of AFI to axis convert AFI to an index;","category":"page"},{"location":"internal/#AbstractNotIndex-interface","page":"Internal","title":"AbstractNotIndex interface","text":"","category":"section"},{"location":"internal/","page":"Internal","title":"Internal","text":"AbstractNotIndex is a subtype of AbstractFunctionIndex, which represents an inverted index. To define a new type of AbstractNotIndex, the only needed method is Base.parent, which returns the parent index which is inverted by this index. to_function for AbstractNotIndex is pre-defined as notin(parent(I)).","category":"page"},{"location":"internal/#example","page":"Internal","title":"Define a new NotIndex","text":"","category":"section"},{"location":"internal/","page":"Internal","title":"Internal","text":"If you don't like the default behaviour of not, creating a new Notindex type is easy:","category":"page"},{"location":"internal/","page":"Internal","title":"Internal","text":"using FunctionIndices\nstruct YatAnotherNotIndex{T} <: FunctionIndices.AbstractNotIndex{T}\n    parent::T\nend\nconst YANI = YatAnotherNotIndex\nBase.parent(I::YatAnotherNotIndex) = I.parent\nreshape(1:10, 2, 5)[YANI(1), YANI(2)]","category":"page"},{"location":"internal/","page":"Internal","title":"Internal","text":"If a big array of linear indices I should be excluded, create a new index array by setdiff might faster than map(!in(I)). You can do this by defining indextype and to_index for YANI:","category":"page"},{"location":"internal/","page":"Internal","title":"Internal","text":"FunctionIndices.indextype(::Type{<:AbstractArray}, ::Type{<:YANI{<:Array{<:Integer}}}) = Vector{Int}\nFunctionIndices.to_index(::Type{Vector{Int}}, A, ind, I::YANI{<:Array{<:Integer}}) = setdiff(ind, parent(I))::Vector{Int}\nto_indices(0:10, (YANI([1, 2, 3]),))","category":"page"},{"location":"#FunctionIndices","page":"FunctionIndices","title":"FunctionIndices","text":"","category":"section"},{"location":"","page":"FunctionIndices","title":"FunctionIndices","text":"(Image: Build Status) (Image: codecov) (Image: GitHub) (Image: Docs stable) (Image: Docs dev)","category":"page"},{"location":"","page":"FunctionIndices","title":"FunctionIndices","text":"A small package allows indexing array with functions via a simple wrapper FI. For example, A[FI(iseven)] returns an array containing all elements of A whose indices instead of values are even, like (0:3)[FI(iseven)] == [1, 3]. To access elements whose values are even, try filter(iseven, A). As a special case, for indexing with !=(i) or !in(I), which are expected to get elements whose index are not is i or not in I, there is another wrapper not providing a convenient and optimized way. The not is similar to Not of InvertedIndices, but faster in some cases, see performance comparing for more information.","category":"page"},{"location":"#Quick-start-to-index-with-function-index","page":"FunctionIndices","title":"Quick start to index with function index","text":"","category":"section"},{"location":"","page":"FunctionIndices","title":"FunctionIndices","text":"1-d indexing A[FI(f)] is equivalent to A[map(f, begin:end)], multidimensional indexing A[FI(f1), ..., FI(fn)] is equivalent to A[map(FI(f1), axes(A, 1)), ..., map(FI(fn), axes(A, n))].","category":"page"},{"location":"","page":"FunctionIndices","title":"FunctionIndices","text":"julia> using FunctionIndices\n\njulia> A = reshape(0:11, 3, 4)\n3×4 reshape(::UnitRange{Int64}, 3, 4) with eltype Int64:\n 0  3  6   9\n 1  4  7  10\n 2  5  8  11\n\njulia> A[FI(iseven)]\n6-element Vector{Int64}:\n  1\n  3\n  5\n  7\n  9\n 11\n\njulia> A[map(iseven, begin:end)]\n6-element Vector{Int64}:\n  1\n  3\n  5\n  7\n  9\n 11\n\njulia> A[FI(isodd), FI(iseven)]\n2×2 Matrix{Int64}:\n 3   9\n 5  11\n\njulia> A[map(isodd, begin:end), map(iseven, begin:end)]\n2×2 Matrix{Int64}:\n 3   9\n 5  11","category":"page"},{"location":"","page":"FunctionIndices","title":"FunctionIndices","text":"not is an alternative to Not, and in most cases they are equivalent:","category":"page"},{"location":"","page":"FunctionIndices","title":"FunctionIndices","text":"julia> using InvertedIndices\n\njulia> A[not(1)] == A[Not(1)]\ntrue\n\njulia> A[not(1, 2)] == A[Not(1, 2)]\ntrue\n\njulia> A[not(1:2)] == A[Not(1:2)]\ntrue\n\njulia> let I = rand(Bool, size(A)); A[not(I)] == A[Not(I)] end\ntrue","category":"page"},{"location":"","page":"FunctionIndices","title":"FunctionIndices","text":"But for CartesianIndex and CartesianIndices, A[not(CartesianIndex(i, j,...))] is equivalent to A[not(i), not(j), ...] and A[not(CartesianIndices((I, J,...))] is equivalent to A[not(I), not(J), ...], where not treats inverted Cartesian indices as Cartesian inverted indices, and always returns an array with the same dimension. However, A[Not(CartesianIndex(i, j,...))] converts CartesianIndex to linear index and return a vector, and A[Not(CartesianIndices((I, J,...)))] seems an undefined behaviour.","category":"page"},{"location":"","page":"FunctionIndices","title":"FunctionIndices","text":"julia> A[not(CartesianIndex(1, 2))] # equivalent to A[not(1), not(2)]\n2×3 Matrix{Int64}:\n 1  7  10\n 2  8  11\n\njulia> A[Not(CartesianIndex(1, 2))] # equivalent to A[Not(3)]\n11-element Vector{Int64}:\n  0\n  1\n  2\n  4\n  5\n  ⋮\n  8\n  9\n 10\n 11\n\njulia> A[not(CartesianIndex(1, 2):CartesianIndex(2, 3))] # equivalent to A[not(1:2), not(2:3)]\n1×2 Matrix{Int64}:\n 2  11\n\njulia> A[Not(CartesianIndex(1, 2):CartesianIndex(2, 3))] # seems an undefined behavior\n1×2 Matrix{Int64}:\n 5  8","category":"page"},{"location":"","page":"FunctionIndices","title":"FunctionIndices","text":"Besides, for out of bounds index like A[4, 5], A[not(4), not(5)] is equivalent to A[:, :], because inbounds indices are not equal to the given value, while A[Not[4], Not(5)] throws a BoundsError.","category":"page"},{"location":"","page":"FunctionIndices","title":"FunctionIndices","text":"This package is also compatible with OffsetArrays:","category":"page"},{"location":"","page":"FunctionIndices","title":"FunctionIndices","text":"julia> using OffsetArrays\n\njulia> OA = OffsetArray(A, 2:4, 0:3)\n3×4 OffsetArray(reshape(::UnitRange{Int64}, 3, 4), 2:4, 0:3) with eltype Int64 with indices 2:4×0:3:\n 0  3  6   9\n 1  4  7  10\n 2  5  8  11\n\njulia> OA[FI(iseven), FI(iseven)] # OA[[2, 4], [0, 2]]\n2×2 Matrix{Int64}:\n 0  6\n 2  8\n\njulia> OA[not(2), not(3)] # OA[[3, 4], [0, 1, 2]]\n2×3 Matrix{Int64}:\n 1  4  7\n 2  5  8","category":"page"}]
}
