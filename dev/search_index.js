var documenterSearchIndex = {"docs":
[{"location":"performance/#performance","page":"Performance comparing","title":"Performance comparing","text":"","category":"section"},{"location":"performance/","page":"Performance comparing","title":"Performance comparing","text":"This is a performance comparing of \"Invert Indexing\" for different methods. There are four methods:","category":"page"},{"location":"performance/","page":"Performance comparing","title":"Performance comparing","text":"bymap: test if it is not in given no for each index of A by map,\nbyfilter: removing no from index by filter,\nbyNot: by InvertedIndices.Not,\nbynot: by not of this package.","category":"page"},{"location":"performance/","page":"Performance comparing","title":"Performance comparing","text":"This is the detail of benchmark. the minimum time of each methods for different type of index were compared:","category":"page"},{"location":"performance/","page":"Performance comparing","title":"Performance comparing","text":"using BenchmarkTools\nusing InvertedIndices\nusing FunctionIndices\nusing Latexify\n\n# Linear\nbynot(A, no) = A[not(no)]\nbyfi(A, no) = A[FI(!in(no))]\nbymap(A, no) = A[map(!in(no), begin:end)]\nbyfilter(A, no) = A[filter(!in(no), begin:end)]\nbyNot(A, no) = A[Not(no)]\n\n# Cartesian\nbynot(A, nos...) = A[ntuple(i -> not(nos[i]), Val(length(nos)))...]\nbyfi(A, nos...) = A[ntuple(i -> FI(!in(nos[i])), Val(length(nos)))...]\nbymap(A, nos...) = A[ntuple(i -> map(!in(nos[i]), axes(A, i)), Val(length(nos)))...]\nbyfilter(A, nos...) = A[ntuple(i -> filter(!in(nos[i]), axes(A, i)), Val(length(nos)))...]\nbyNot(A, nos...) = A[ntuple(i -> Not(nos[i]), Val(length(nos)))...]\n\nconst As = (rand(10), rand(10, 10), rand(10, 10, 10))\nconst fs = (bynot, byfi, bymap, byfilter, byNot)\n\n# convert tuple of tuple to matrix\ntt2mt(trs) = hcat(map(tr -> vcat(tr...), trs)...)\n\nmaketable(bench, As::Tuple=As, fs::Tuple=fs) = mdtable(\n    # use map of map instead of for loop for typle stable\n    map(\n        f -> map(\n            A -> begin\n                trial = bench(f, A)\n                trialmin = minimum(trial)\n                trialallocs = allocs(trialmin)\n                string(\n                    BenchmarkTools.prettytime(time(trialmin)),\n                    \" (\", trialallocs , \" alloc\",\n                    trialallocs == 1 ? \"\" : \"s\", \": \",\n                    BenchmarkTools.prettymemory(memory(trialmin)), \")\"\n                )\n            end,\n            As\n        ),\n        fs\n    ) |> tt2mt;\n    head=fs, side=[:Size; size.(As)...], latex=false,\n);","category":"page"},{"location":"performance/#Indexing-with-Int","page":"Performance comparing","title":"Indexing with Int","text":"","category":"section"},{"location":"performance/","page":"Performance comparing","title":"Performance comparing","text":"A random inbounds Int index.","category":"page"},{"location":"performance/#Linear-Indexing","page":"Performance comparing","title":"Linear Indexing","text":"","category":"section"},{"location":"performance/","page":"Performance comparing","title":"Performance comparing","text":"maketable() do f, A\n    ind = rand(firstindex(A):lastindex(A))\n    @benchmark $f($A, $ind)\nend","category":"page"},{"location":"performance/#Multi-dimensional-Indexing","page":"Performance comparing","title":"Multi-dimensional Indexing","text":"","category":"section"},{"location":"performance/","page":"Performance comparing","title":"Performance comparing","text":"maketable() do f, A\n    inds = ntuple(i -> rand(axes(A, i)), Val(ndims(A)))\n    @benchmark $f($A, $inds...)\nend","category":"page"},{"location":"performance/#Indexing-with-UnitRange","page":"Performance comparing","title":"Indexing with UnitRange","text":"","category":"section"},{"location":"performance/","page":"Performance comparing","title":"Performance comparing","text":"A random inbound UnitRange with half length of axe.","category":"page"},{"location":"performance/#Linear-Indexing-2","page":"Performance comparing","title":"Linear Indexing","text":"","category":"section"},{"location":"performance/","page":"Performance comparing","title":"Performance comparing","text":"maketable() do f, A\n    axe = firstindex(A):lastindex(A)\n    half = length(axe) ÷ 2\n    b = rand(axe[begin:(end - half)])\n    e = b + half\n    @benchmark $f($A, $(b:e))\nend","category":"page"},{"location":"performance/#Multi-dimensional-Indexing-2","page":"Performance comparing","title":"Multi-dimensional Indexing","text":"","category":"section"},{"location":"performance/","page":"Performance comparing","title":"Performance comparing","text":"maketable() do f, A\n    inds = ntuple(\n        i -> begin\n            axe = axes(A, i)\n            half = length(axe) ÷ 2\n            b = rand(axe[begin:(end - half)])\n            e = b + half\n            b:e\n        end,\n        Val(ndims(A))\n    )\n    @benchmark $f($A, $inds...)\nend","category":"page"},{"location":"performance/#Indexing-with-StepRange","page":"Performance comparing","title":"Indexing with StepRange","text":"","category":"section"},{"location":"performance/","page":"Performance comparing","title":"Performance comparing","text":"A StepRange with step 2 and half length of axe.","category":"page"},{"location":"performance/#Linear-Indexing-3","page":"Performance comparing","title":"Linear Indexing","text":"","category":"section"},{"location":"performance/","page":"Performance comparing","title":"Performance comparing","text":"maketable() do f, A\n    ind = firstindex(A):2:lastindex(A)\n    @benchmark $f($A, $ind)\nend","category":"page"},{"location":"performance/#Multi-dimensional-Indexing-3","page":"Performance comparing","title":"Multi-dimensional Indexing","text":"","category":"section"},{"location":"performance/","page":"Performance comparing","title":"Performance comparing","text":"maketable() do f, A\n    inds = ntuple(\n        i -> begin\n            axe = axes(A, i)\n            axe[begin:2:end]\n        end,\n        Val(ndims(A))\n    )\n    @benchmark $f($A, $inds...)\nend","category":"page"},{"location":"performance/#Indexing-with-Vector{Int}","page":"Performance comparing","title":"Indexing with Vector{Int}","text":"","category":"section"},{"location":"performance/","page":"Performance comparing","title":"Performance comparing","text":"A Vector{Int} which is a collected StepRange.","category":"page"},{"location":"performance/#Linear-Indexing-4","page":"Performance comparing","title":"Linear Indexing","text":"","category":"section"},{"location":"performance/","page":"Performance comparing","title":"Performance comparing","text":"maketable() do f, A\n    ind = collect(firstindex(A):2:lastindex(A))\n    @benchmark $f($A, $ind)\nend","category":"page"},{"location":"performance/#Multi-dimensional-Indexing-4","page":"Performance comparing","title":"Multi-dimensional Indexing","text":"","category":"section"},{"location":"performance/","page":"Performance comparing","title":"Performance comparing","text":"maketable() do f, A\n    inds = ntuple(\n        i -> begin\n            axe = axes(A, i)\n            collect(axe[begin:2:end])\n        end,\n        Val(ndims(A))\n    )\n    @benchmark $f($A, $inds...)\nend","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A small package allows to index arrays by a function via a simple wrapper FI. Besides, for indexing with !=(n), !in(itr), there is another wrapper not providing a convenient and optimized way, which is similar to Not of InvertedIndices., but faster in some cases.","category":"page"},{"location":"#References","page":"Introduction","title":"References","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Modules = [FunctionIndices]","category":"page"},{"location":"#FunctionIndices.AbstractFunctionIndex","page":"Introduction","title":"FunctionIndices.AbstractFunctionIndex","text":"AbstractFunctionIndex\n\nSupertype of all function index types.\n\n\n\n\n\n","category":"type"},{"location":"#FunctionIndices.AbstractNotIndex","page":"Introduction","title":"FunctionIndices.AbstractNotIndex","text":"AbstractNotIndex{T}\n\nSupertype of all not types which create by not.\n\n\n\n\n\n","category":"type"},{"location":"#FunctionIndices.FunctionIndex","page":"Introduction","title":"FunctionIndices.FunctionIndex","text":"FunctionIndex{F} <: AbstractFunctionIndex\nFI\n\nA implementation of function index, which make indexing with function possible. 1-d indexing A[FI(f)] is equivalent to A[map(f, begin:end)], multi-dimensional indexing A[FI(f1), ..., FI(fn)] is equivalent to A[map(FI(f1), axes(A, 1)), ..., map(FI(fn), axes(A, n))].\n\n\n\n\n\n","category":"type"},{"location":"#FunctionIndices.NotIndex","page":"Introduction","title":"FunctionIndices.NotIndex","text":"NotIndex{T} <: AbstractNotIndex{T}\n\nThe default implementation of not. There are some optimization for NotIndex(x) comparing to FI(!in(x)). For large arrays, this implementation may be faster. but for small arrays this implementation may be slower. See performance comparing for more details.\n\nOptimization can be enable/disable by override optimized.\n\n\n\n\n\n","category":"type"},{"location":"#FunctionIndices.not-Tuple{Any}","page":"Introduction","title":"FunctionIndices.not","text":"not(x)\n\nCreate a NotIndex with given x, which is similar to Not of InvertedIndices. In most cases, not is much faster than Not. See performance comparing for more details.\n\nMain differences between not and Not\n\nFor CartesianIndex, A[not(CartesianIndex(i, j,..., n))] is equivalent to A[not(i), not(j), ..., not(n)] and will return a array with same dimension, but A[Not(CartesianIndex(i, j,..., n))] will convert the CartesianIndex to a linear index and return a vector:\n\njulia> A = reshape(1:12, 3, 4)\n3×4 reshape(::UnitRange{Int64}, 3, 4) with eltype Int64:\n 0  3  6   9\n 1  4  7  10\n 2  5  8  11\n\njulia> A[not(CartesianIndex(1, 2))] # equivalent to A[not(1), not(2)]\n2×3 Matrix{Int64}:\n 1  7  10\n 2  8  11\n\njulia> A[Not(CartesianIndex(1, 2))] # equivalent to A[Not(3)]\n11-element Vector{Int64}:\n  0\n  1\n  2\n  4\n  5\n  ⋮\n  8\n  9\n 10\n 11\n\nBesides, for index like A[4, 5] which is out of bounds, A[not(4), not(5)] is equivalent to A[:, :], because inbounds indices are always not equal to the given value, while A[Not[4], Not(5)] causes an error.\n\n\n\n\n\n","category":"method"},{"location":"#FunctionIndices.optimized-Tuple{Any, Any}","page":"Introduction","title":"FunctionIndices.optimized","text":"optimized(A, I) -> StaticBool\noptimized(::Type{TA}, ::Type{TI}) -> StaticBool\n\nDetermine whether try optimized indexing for given type of TA and TI. By default, it's False() for TI<:AbstractFunctionIndex and True() for TI<:NotIndex.\n\nOverride optimized(::Type{TA}, ::Type{TI}) to enable/disable optimized indexing for given type.\n\n\n\n\n\n","category":"method"},{"location":"#FunctionIndices.to_index-Tuple{FunctionIndices.StaticBool, Any, Any}","page":"Introduction","title":"FunctionIndices.to_index","text":"FunctionIndices.to_index(::StaticBool, ind, i)\n\nConvert a AbstractFunctionIndex i to a array index with ind. The first argument of an optimized methods should be True, like to_index(::True, ind, i).\n\n\n\n\n\n","category":"method"}]
}
